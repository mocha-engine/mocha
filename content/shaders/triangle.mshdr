#version 450

#define DEBUG_VIEW_NONE 					0
#define DEBUG_VIEW_DIFFUSE 					1
#define DEBUG_VIEW_NORMAL 					2
#define DEBUG_VIEW_AMBIENTOCCLUSION 		3
#define DEBUG_VIEW_METALNESS 				4
#define DEBUG_VIEW_ROUGHNESS 				5
#define DEBUG_VIEW_OTHER					63

struct fs_in
{
	vec3 vColor;
	vec3 vPositionWS;
	vec3 vCameraWS;
	vec2 vTexCoord;
	vec3 vNormalWS;

	vec4[4] vLightInfoTS;
	vec3 vCameraTS;
	vec3 vPositionTS;
	vec3 vNormalTS;

	vec3 vDebug;
	mat3 mTBN;
};

//push constants block
layout( push_constant ) uniform constants
{
	vec4 data;				// 4

	mat4 model_matrix;		// 16

	mat4 render_matrix;		// 16

	vec3 vCameraPosWS;		// 3
	float flTime;			// 1

	vec4[4] vLightInfoWS;	// 16
} PushConstants;

#ifdef VERTEX

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec3 vNormal;
layout (location = 2) in vec3 vColor;
layout (location = 3) in vec2 vTexCoord;
layout (location = 4) in vec3 vTangent;
layout (location = 5) in vec3 vBitangent;

layout (location = 0) out fs_in vs_out;

void main()
{
	//
	// Basic params
	//
	vs_out.vPositionWS = vec3( PushConstants.model_matrix * vec4( vPosition, 1.0f ) );
	vs_out.vCameraWS = PushConstants.vCameraPosWS;
	vs_out.vColor = vColor;
	vs_out.vTexCoord = vTexCoord;
	vs_out.vNormalWS = vNormal;

	//
	// Calculate TBN matrix for lighting
	//
	vec3 T = normalize( vec3( PushConstants.model_matrix * vec4( vTangent, 0.0 ) ) );
	vec3 B = normalize( vec3( PushConstants.model_matrix * vec4( vBitangent, 0.0 ) ) );
	vec3 N = normalize( vec3( PushConstants.model_matrix * vec4( vNormal, 0.0 ) ) );
	mat3 TBN = transpose( mat3( T, B, N ) );

	//
	// Transform into tangent space
	//
	for ( int i = 0; i < 4; i++ )
	{
		vec3 lightPos = PushConstants.vLightInfoWS[i].xyz;
		lightPos = TBN * lightPos;

		float lightIntensity = PushConstants.vLightInfoWS[i].w;
		vs_out.vLightInfoTS[i] = vec4( lightPos, lightIntensity );
	}
	
	vs_out.vCameraTS = TBN * vs_out.vCameraWS;
	vs_out.vPositionTS = TBN * vs_out.vPositionWS;
	vs_out.vNormalTS = TBN * vs_out.vNormalWS;
	vs_out.mTBN = TBN;

	vs_out.vDebug = vs_out.vPositionWS;
	
	//
	// Finish - transform into clip space
	//
	gl_Position = PushConstants.render_matrix * vec4( vPosition, 1.0f );
}

#endif

#ifdef FRAGMENT

#define PI				3.14159265359

layout (location = 0) in fs_in vs_out;

layout (location = 0) out vec4 outFragColor;

layout (set = 0, binding = 0) uniform sampler2D diffuseTexture;
layout (set = 0, binding = 1) uniform sampler2D normalTexture;
layout (set = 0, binding = 2) uniform sampler2D ambientOcclusionTexture;
layout (set = 0, binding = 3) uniform sampler2D metalnessTexture;
layout (set = 0, binding = 4) uniform sampler2D roughnessTexture;

vec3 fresnelSchlick( float cosTheta, vec3 F0 )
{
	return F0 + ( 1.0f - F0 ) * pow( 1.0f - cosTheta, 5.0f );
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
	
    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
	
    return num / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);
	
    return ggx1 * ggx2;
}

vec3 calculateLighting( float roughness, float metallic, vec3 albedo, vec3 lightPos, float intensity, vec3 V, vec3 N )
{
	vec3 L = normalize( lightPos - vs_out.vPositionTS );
	vec3 H = normalize( V + L );

	float distance = length( lightPos - vs_out.vPositionTS );
	float attenuation = 1.0f / ( distance * distance );
	vec3 radiance = vec3( 1.0f, 1.0f, 1.0f ) * attenuation * intensity;

	vec3 F0 = vec3( 0.04 );
	F0 = mix( F0, albedo, metallic );

	float NDF = DistributionGGX( N, H, roughness );
	float G = GeometrySmith( N, V, L, roughness );
	vec3 F = fresnelSchlick( max( dot( H, V ), 0.0 ), F0 );

	vec3 kS = F;
	vec3 kD = vec3( 1.0 ) - kS;
	kD *= 1.0 - metallic;

	vec3 numerator = NDF * G * F;
	float denominator = 4.0 * max( dot( N, V ), 0.0 ) * max( dot( N, L ), 0.0 ) + 0.0001;
	vec3 specular = numerator / denominator;

	float NdotL = max( dot( N, L ), 0.0 );
	
	return ( kD * albedo / PI + specular ) * radiance * NdotL;
}

float ambient()
{
	return 0.05;
}

vec3 sampleTexture( sampler2D target )
{
	return texture( target, vs_out.vTexCoord.xy * vec2( -1, 1 ) ).rgb;
}

void main()
{
	// Collect material properties
	vec3 albedo = sampleTexture( diffuseTexture );
	float metallic = sampleTexture( metalnessTexture ).r;
	float roughness = sampleTexture( roughnessTexture ).r;
	float ao = sampleTexture( ambientOcclusionTexture ).r;

	vec3 vNormalTS = sampleTexture( normalTexture );
	vNormalTS = vNormalTS * 2.0 - 1.0;

	// If we don't have a normal map, use the vertex normal
	if ( vNormalTS.z > 0 )
		vNormalTS = vs_out.vNormalTS;

	// Recalculate Z axis - BC5 stomps it
	vNormalTS.z = sqrt( 1.0 - vNormalTS.x * vNormalTS.x - vNormalTS.y * vNormalTS.y );

	vec3 viewDir = normalize( vs_out.vCameraTS - vs_out.vPositionTS );
	
	vec3 ambient = ambient() * albedo;
	vec3 color = vec3( 0.0 );
	
	for ( int i = 0; i < 4; ++i )
	{
		// Unpack lighting info
		vec3 vLightPosTS = vs_out.vLightInfoTS[i].xyz;
		float flLightIntensity = vs_out.vLightInfoTS[i].w;

		color += calculateLighting( roughness, metallic, albedo, vLightPosTS, flLightIntensity, viewDir, vNormalTS );
	}

	vec3 fragColor = ambient + color;

	// Ambient occlusion
	fragColor *= ao;

	// Gamma correction
	fragColor = fragColor / ( fragColor + vec3( 1.0f ) );
	fragColor = pow(fragColor, vec3(1.0f / 2.2f));

	int debugView = int( floor( PushConstants.data.x ) );

	if ( debugView == DEBUG_VIEW_DIFFUSE )
		fragColor = albedo;
	else if ( debugView == DEBUG_VIEW_NORMAL )
		fragColor = vNormalTS;
	else if ( debugView == DEBUG_VIEW_AMBIENTOCCLUSION )
		fragColor = ao.xxx;
	else if ( debugView == DEBUG_VIEW_METALNESS )
		fragColor = metallic.xxx;
	else if ( debugView == DEBUG_VIEW_ROUGHNESS )
		fragColor = roughness.xxx;
	else if ( debugView == DEBUG_VIEW_OTHER )
		fragColor = vs_out.vDebug;

	outFragColor = vec4(fragColor, 1.0f);
}

#endif